# Item 15. 클래스와 멤버의 접근 권한을 최소화하라
잘 설계된 컴포넌트는 구현과 API는를 깔끔하게 분리한 컴포넌트이다! <br>
오직 API를 통해서만 외부와 소통하며, 서로의 내부 동작 방식에는 개의치 않는다. 이는 정보 은닉, 캡슐화에 대한 이야기다. <br>

그를 위해선 우리 모두 접근성을 최소로 해서 최소한의 public API를 설계하도록 노력하자. 그 외에는 공개되지 않도록 해야한다 <br>
**public 클래스는 상수용 `public static final` 필드 외세는 어떠한 public 필드도 가져선 안된다!!!!!** `public static final` 필드가 참조하는 객체가 불변인지도 확인해야 한다. <Br>
아주 아주 익숙한 이야기다.. <br>
**객체의 캡슐화를 통해 객체의 자율성을 높혀 스스로 협력하게 하고, 오로지 메시지를 통해서만 협력하여 의존성을 낮추라는 객체지향의 주된 가르침에 관한 이야기다.** 귀에 못이 박히도록 들은. <br>

## 1. 정보 은닉과 컴포넌트 독립의 장점
객체를 독립 시키면, 즉 자율성을 높히면, 다른 객체들은 이 객체의 내부에 관여하지 못한다. 그저, 객체가 내놓은 API와만 통신할 수 있다 <br>
그렇게 되면, 객체는 내부 구현을 얼마든지 맘대로 수정할 수 있다. <br>
이런 이유로 컴포넌트 독립과 정보 은닉의 장점을 **개발, 테스트, 최적화, 적용, 분석, 수정 등을 개별적으로 할 수 있게 해주는 것이라고 하는 것이다.** <br>

장점을 한번 더 적을 테니 기쁜 마음으로 잘 읽어보자.
1. **시스템 개발 속도를 높인다.** 왜? **여러 컴포넌트를 병렬로 개발할 수 있기 때문!**
2. **시스템 관리 비용을 낮춘다:** 컴포넌트 파악이 빨라 디버깅이 쉬워지고, 교체 비용도 저렴해지기 때문!
3. **성능 최적화에 도움을 준다:** 조금 간접적이기는 한데, 어떤 컴포넌트를 최적화 하고자 할 때, 다른 컴포넌트에 영향을 미치지 않고 최적화를 할 수 있기 때문이다.
4. **소프트웨어 재사용성을 높인다:** 외부에 대한 의존이 낮기 때문에, 다른 환경에서도 쓰일 수 있기 때문이다.
5. **큰 시스템의 제작 난이도를 낮춰준다:** 시스템 전체를 개발하지 않아도, 개별 컴포넌트의 동작을 검증할 수 있기 때문!

<br>

## 2. 모든 클래스와 맴버의 접근성을 가능한 한 좁혀라
자바는 정보 은닉을 위한 다양한 장치들을 제공하는데, 그 중 클래스, 인터페이스, 맴버의 접근성을 접근 제한자를 통해 제한한다. <Br>
**정보 은닉의 핵심은 이 접근 제한자를 잘 활용하는 것!** <br>

기본 원칙은 `모든 클래스와 맴버의 접근성을 가능한 한 좁히는 것`이다. <br>
**소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다는 뜻이다.** <br>

\[원칙들!]
1. **클래스나 인터페이스를 패키지 외부에서 사용할 일이 없다면 package-private로 선언하자.** <br> 그러면 API가 아닌 내부 구현이 되어 언제든 수정이 가능하다.
2. **한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스 안에 `private static`으로 중첩시켜라!** <br> 톱레벨로 두면 패키지 내 모든 클래스에서 접근 가능하지만, `private static`으로 중첩시키면 **바깥 클래스 하나에서만 접근할 수 있다.** 
3. pulbic일 필요가 없는 클래스의 접근 수준을 package-private 톱레벨 클래스로 좁혀라. 즉, **public일 필요가 없다면 API가 아닌 내부구현화 하라는 것이다.**
4. Serializable을 구현한 클래스의 필드들이 의도치 않게 공개 API가 되는 것을 조심해라.
5. protected 또한 공개 API이므로, 영원히 관리해야 한다. 따라서, 적을 수록 좋다.


## 조심해야 할점

접근 수준을 좁히는데 있어, 조심해야 할점들이 있다.
1. **리스코프 치환 원칙:** 리스코프 치환 원칙으로 인해 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다. <Br> 즉, **상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서 보다 좁게 설정할 수 없다.** 
2. 테스트를 목적으로 접근 범위를 넓히지 말자. <br> public 클래스의 private 맴버를 package-private까지 풀어줄 수는 있지만, 그 이상은 안된다. **테스트를 목적으로 클래스, 인터페이스, 맴버를 공개 API로 만들지 마라!**
3. **public 클래스의 인스턴스 필드는 되도록 public이 아니여야 한다.** <br> 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언한다면... **그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다.** <br> **그 필드와 관련된 모든 것은 불변식을 보장할 수 없게 된다.** 또한 필드가 수정될 때 락 획득과 같은 다른 작업을 할 수 없게 되므로, **public 가변 필드를 갖는 클래슨느 일반적으로 스레드 안전하지 않다!** <Br> 필드가 final이면서 불변 객체를 참조하더라고, public을 지워내는 방식 등의 내부 구현 변경을 시도할 수 없게 된다. **그냥 public 클래스의 인스턴스 필드는 public이 아니게 해라.**
4. 기본 타입 값이나, 불변 객체를 참조하는 상수라면 `public static final` 필드로 공개해도 좋다.
5. **클래스에서 `public static final` 배열 필드를 두거나, 해당 필드를 반환하는 접근자 메서드를 제공하지 마라.** 길이가 0이 아닌 배열은 모두 변경 가능하기 때문이다! <br> 대신 이하의 방법을 권한다. <br> 1. public 배열을 private로 만들고, 해당 배열을 통해 만든 public 불변 리스트를 추가하는 것이다 (??) <br> 2. 배열을 private로 만들고 그 복사본을 반환하는 public 메서드를 만드는 방어적 복사 기법을 이용해라.



## Reference
- Effective Java <조슈아 블로크>
