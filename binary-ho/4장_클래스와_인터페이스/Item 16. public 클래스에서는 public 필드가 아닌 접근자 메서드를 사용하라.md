# Item 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.
사실 접근자 메서드를 사용해야 함은 귀에 못이 박히도록 들어 알고 있었다. <br> 
그것이 캡슐화니까.. 끄덕 <br>
이번 아이템을 통해 그 장점을 다시 한번 자세히 살펴보자. <br>


## 의존성을 낮출 수 있다.
필드들에 직접 접근하는 것을 허용하지 않고, 접근자 메서드를 사용하는 것의 가장 큰 장점은 의존성에 있다. <br>

날것의 필드를 노출하고, 클라이언트가 수정하거나 읽게 한다면, 중간에 해당 클래스가 손쓸 방법이 없다. <br>
막을 방법이 없다는 이야기가 아니라, 어떤 변화를 가하거나, 제한을 걸 수 없다는 이야기다. <br>
예를 들어 getter를 생각해보자. <br>
예를 들어 주민등록번호 필드에 대한 getter 없이 그냥 날것으로 쓰게 해줬다고 생각해보자. <Br>
그러던 어느날, 주민등록번호의 뒷자리는 보여주기 싫어져도 클래스는 대처할 방법이 없다. <Br>
하지만 getter와 setter 같은 메서드를 제공하면, 클라이언트가 이들을 통해 필드를 읽거나, 수정해도 중간에 클래스가 나서서 조취를 취할 수 있다. <Br>
주민등록 번호의 경우, 원한다면 내가 위조를 해도 되고, 아니면 뒷자리는 *로 바꾸어도 된다. <Br> 
그러니까 **객체의 자율성이 높아지게 된다.** <br>
객체 스스로가 내놓는 방식, 받아들이는 방식을 바꿀 수 있다는 것이다. <br>
그러면 또 필요에 따라 클래스의 내부 표현 방식을 맘대로 바꿀 수 있다. <Br>
그저 클라이언트가 메서드 들을 호출했을 때 기대하는 부분만 채워준다면, 자유롭게 수정할 수 있다.

## 불변 클래스
public 필드가 불변이라면, 직접 노출하는 것의 단점이 줄어 보일 수도 있다. <br>
그러나 이 상황에서도 API 변경 없이 표현 방식을 바꿀 수 없다는 단점이 여전히 존재하기 떄문에 권하지 않는다

### 예외
package-private 클래스 또는 private nested class라면 데이터 필드를 노출한다 해도 문제 없다. <br>
어떻게 보면 클라이언트 코드가 이 클래스 내부 표현에 묶인다고 생각할 수 있지만, 어차피 그 클라이언트 코드도 이 클래스를 포함한 패키지 안에서 동작하는 코드이기 때문이다. 

## 요약
public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다. 불변 필드라면 노출해도 덜 위험할 수도 있지만 안심할 수는 없다. <br>
하지만 종종 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다.

## Reference
- Effective Java <조슈아 블로크>
