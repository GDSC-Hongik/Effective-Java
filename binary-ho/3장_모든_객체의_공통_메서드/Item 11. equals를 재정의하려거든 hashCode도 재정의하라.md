# Item 11. equals를 재정의하려거든 hashCode도 재정의하라.
인스턴스의 hashCode는 **HashMap이나 HashSet과 같은 컬렉션의 원소로 쓰인다.** <br>
해쉬값으로 각 인스턴스를 판단하기 때문에, <br>
**논리적으로 같은 객체라면 같은 hashCode를 반환해야 한다.** 따라서, equals를 재정의할 때는 hashCode도 반드시 재정의 해야 한다! <br>
논리적으로 같은 객체인데 다른 hashCode를 반환한다면, Map이나 Set에서 해당 인스턴스를 잃어버리게 되는 것이나 마찬가지다.. <Br>
각 버킷을 해쉬값으로 구분하니까 당연하다. 앞서 언급한 경우, 다른 버킷을 열심히 뒤지고 다닐테니까 그렇다.. <br>

다른 인스턴스가 같은 hashCode를 반환하는건 그래도 괜찮다. 버킷을 좀 더 뒤지면 그만이기 때문이다. <Br>

## 1. Object 명세 규약
```
1. equals 비교에 사용되는 정보가 변하지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 같은 값을 반환해야 한다.
2. equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
3. equals가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 값을 반환해야 해시 테이블의 성능이 좋아진다.
```
앞서 말한 내용들은 전부 규약을 통해 판단한 내용들이다. hashCode는 변하지 말아야 하고, 논리적으로 같은 객체라면 같은 hashCode를 반환해야 하며, 다른 객체의 경우 같은 값을 반환해도 괜찮다. 다만 조금더 느릴 뿐이다. <br> 
이 규약들을 따르며 hashCode를 작성하는 요령을 알아보자.

## 2. hashCode를 작성하는 요령
요령을 보여주기 전에 예시를 먼저 보여주고 싶다. <Br>
요령이 아주 복잡하기 때문이다. 아래는 areaCode, prefix, lineNum을 필드로 가진 PhonNumber 클래스에 대한 hashCode이다.
```java
@Override public int hashCode() {
  int result = Short.hashCode(areaCode);
  result = 31 * result + Short.hashCode(prefix);
  result = 31 * result + Short.hashCode(lineNum);
  return result;
}
```
**모든 중요 필드에 대해 기본 hashCode 메서드를 호출했고, 홀수인 소수 31을 계속 곱해줬다.** 마치 자릿수를 한칸씩 올리며 연산하듯 말이다. <br>

요령을 살펴보자
1. int 변수 result를 선언한 후 첫 핵심 필드를 `2.a`방식으로 해시코드를 c를 계산하여 해시코드 초기화한다.
2. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행한다.
a. **해당 필드의 해시코드 c를 계산하여** 2.b 방식대로 갱신한다. <br>
  i. 기본 타입 필드라면 Type.hashCode(f)를 수행한다.
  ii. 참조 타입 필드면서 equals 메서드가 이 필드의 equals 메서드를 재귀적으로 호출해 비교한다면, 이 필드의 hashCode를 재귀적으로 호출한다. 필드의 값이 null이면 0을 사용한다 -> 이해 못했다.
  iii. **필드가 배열이라면 핵심 원소 각각을 별도의 필드처럼 다룬다.** 모든 원소가 핵심 원소라면, `Arrays.hashCode`를 사용한다.
b. `단계 2.a`에서 계산한 해시코드 c로 result를 갱신한다. 예를 들어 `result = 31 * result + c;`와 같이 한다.
3. result를 반환한다.


왜 예시를 먼저 보여줬는지 알겠는가? 너무나도 복잡하다. <Br>

2.a의 너무 지엽적인 내용을 빼고 보면 안 복잡하게 느껴질 수도 있다. <br>
**그냥 모든 필드에 대해 해싱한 값을 더해나가는데, 더하기 전에 소수이면서 홀수인 어떤 수를 더해주라는 것이다!** <br>


## 3. 다른 방법들
1. 앞선 아이템에서 언급한 **구글의 AutoValue 프레임워크는 멋진 equals와 hashCode를 자동으로 만들어 준다!** 
2. 해싱이 예민한 상황이라면 구글의 `구아바` 라이브러리를 사용하는 것도 방법이다. <Br>
3. 오토박싱으로 인해 성능이 느리지만, 성능이 예민한 상황이 아니라면 Object 클래스의 `hash` 메서드를 사용하는 것도 좋다.  
    ```java
      @Override public int hashCode() {
        return Objects.hash(lineNum, prefix, areaCode);
      }
    ```
아주 깔끔하기는 하다... <br>


4. 캐싱하는 방법도 고려해라. <br> 클래스가 불변이고, 해시코드 계산 비용이 크다면, **인스턴스가 만들어질 때 해쉬코드를 계산해 두는 것도 좋다!** 
5. 해시의 키로 사용되지 않는 경우라면 지연 초기화 하는 것도 괜찮다.
6. **hashCode의 반환 값의 생성 규칙을 API 사용자에게 공표하지 말라.** <br> 클라이언트가 이 값에 의지하는 것을 막을 수 있고, 그로 인해 추후 내부 구현을 바꿀 수 있다. (개선이 가능하다는 이야기다)

## Reference
- Effective Java <조슈아 블로크>


