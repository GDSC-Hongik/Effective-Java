# Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라.

이제까지 나는 인스턴스를 생성할 때 public 생성자만을 사용해왔다. 중간 중간 다른 방법을 접해 보았지만, 거의 유일한 방법이라도 되는 듯 생성자를 통해서만 인스턴스를 만들어왔다. <br>
하지만, 모든 프로그래머가 꼭 알아둬야 하는 기법이 하나 더 있는데, **바로 `static factory method`를 통해 인스턴스를 만드는 방식이다.** <br>
클래스의 인스턴스를 반환하는 단순한 정적 메서드를 통해 public 생성자를 대신해 인스턴스를 제공할 수 있고, 다양한 장점이 존재한다. <br>
예를 들어 아래와 같이 만든다.
```java
public static Boolean valueOf(boolean b) {
  return b ? Boolean.TRUE : Boolean.FALSE;
}
```
위 메서드는 기본 타입인 boolean 값을 받아서 Boolean 객체 참조로 변환해준다. <br>
```java
public Boolean(boolean b) {
  return b ? Boolean.TRUE : Boolean.FALSE;
}
```
분명 위와 같이 평범하게 퍼블릭 생성자를 제공할 수도 있지만, 왜 `정적 팩터리 메서드`를 사용하는 방식을 고려하라는걸까? <br>
이제부터 그 다섯 가지나 되는 장점을 알아보자.

## 1. 정적 팩터리 메서드를 통한 인스턴스 생성의 장점
1. 이름을 가질 수 있다.
2. 호출될 때마다 새로운 인스턴스를 생성하지 않아도 된다.
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.


### 장점 1. 이름을 가질 수 있다.
머리를 한대 맞은 기분이였다. 이제까지 한 클래스에 아무 생각 없이 여러 생성자를 만들어 사용할 때도 있었다. <br>
넣어주는 인자에 따라 다른 역할을 하는 것은 나 혼자서나 인지하는 일이지, 다른 사람이 해당 객체를 사용할 때는 생성자의 역할을 추측하기가 힘들다. <br>
왜? **이름이 없으니까.** <br>
메서드를 통한 인스턴스 생성은 `메서드`니까 그냥 특성에 맞는 이름을 지어주면 된다! <br>
이름만 잘 짓는 것으로도 반환될 객체의 특성을 바로 알게 해줄 수 있는 것이다. <Br>
예를 들어, `값이 소수인 BigInteger를 반환한다!`라는 의미를 생성자 `BigInteger(int, int, Random)`과 정적 팩터리 메서드 `BigInteger.probablePrime` 중 어느 쪽이 더 잘 전달했는가? <br>
물어보나 마나 메서드 쪽이다! <br>
원래는 힘들게 API 문서를 뜯어보면서 생성자들의 역할을 알아내야 했다면, 이제는 이름만으로도 거의 정확하게 이해할 수 있는 것이다.

### 정적 팩터리 메서드 명명볍!
정적 팩터리 메서드에서 주로 사용하는 명명법을 알아보자.

1. `from`: 매개변수를 **하나** 받아 해당 타입의 인스턴스를 반환함.
2. `of`: 매개변수를 **여러개** 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
3. `valueOf`: from와 of의 더 자세한 버전이다.
4. `instance`, `getInstance`: 만약 매개변수를 받는다면, 매개변수로 명시한 인스턴스를 반환한다. 그렇다고 같은 인스턴스임을 보장하지는 않는다.
5. `create`, `newInstance`: 4번과 비슷하나, **매번 새로운 인스턴스를 생성해서 반환하는 것을 보장한다.**
6. `getType`: getInstance와 같으나, **생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 떄 쓴다.** <br> 예를 들어 `FileStore fs = Files.getFileStore(path)`와 같이 사용한다. Type이 들어갈 곳에 메서드가 반환할 객체의 타입을 적는다.
7. `newType`: newInstance와 같으나, 6번과 같이 생성할 클래스가 아닌, 다른 클래스에 팩터리 메서드를 정의할 때 사용한다.
8. `type`: getType과 newType의 간결한 버전이다.


### 장점 2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.

이제 **객체의 인스턴스를 어딘가에서 받아갈 때, 진짜로 새로 만들어서 줄지, 아니면 미리 만들어 놓거나 캐싱한 것을 재활용할지 프로그래머가 맘대로 정할 수 있게 되었다!** <br>
위에서 보인 `Boolean.valueOf(boolean)`은 객체를 새로 만들지 않는다! <br>
덕분에 생성 비용이 큰 객체들에 대한 최적화를 프로그래머 맘대로 도입할 수 있다. <br>
인스턴스를 통제하면서, 클래스를 싱글턴으로, 인스턴스화 불가 클래스로 만들 수 있다. 그리고 불변 값 클래스에서 동일한 인스턴스가 단 하나뿐임을 보장할 수도 있다! <br> 이렇게 통제된 클래스를 `인스턴스 통제 클래스`라고 부른다!

### 장점 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
엄청난 장점이다.. 덕분에 **반환할 객체 클래스를 내 맘대로 자유롭게 선택할 수 있다!** <br>
**엄청난 유연성을 제공해준다!** <br>
구체적인 구현 클래스를 공개하지 않고고, 객체를 반환할 수 있어서 API를 작게 유지할 수 있다.

### 장점 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
3번과 비슷하게 느껴진다. **반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관이 없다!** <br>
실제로 OpenJDK의 EnumSet클래스는 정적 팩터리 메서드를 통해 인스턴스를 제공하는데, 원소의 수에 따라 다른 하위 클래스를 반환해준다! <br>
클라이언트는 이 하위 클래스들의 존재를 모르고도 잘 사용할 수 있게 되는 것이다.

### 장점 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
(제대로 이해하지 못했다. JAVA를 더 배워나가며 채울 예정)


## 2. 정적 팩터리 메서드 사용의 단점
1. 상속을 하려면 public이나, protected 생성자가 필요한데, **정적 팩터리 메서드만 제공하면 하위클래스를 만들 수 잆다.**
2. **`메서드`이므로, 프로그래머가 찾기 힘들다.** <br> 생성자처럼 API에 직접 드러나는 것이 아니기 때문에, 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화 하는 방법을 알아내야 한다. <br> 앞서 언급한 자주 사용하는 명명법을 이용해서 이런 단점을 완화 시키는 것이 좋을것 같다.


## 3. 핵심 정리
정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있다. <br>
따라서 상대적인 장단점을 이해하고 사용하는 것이 좋다! <br>
보통은 정적 팩터리 메서드를 사용하는게 유리한 경우가 많다.


## Reference
- Effective Java <조슈아 블로크>
