# Item 51 : 메서드 시그니처를 신중히 설계하라

# 메서드 시그니처

메서드 시그니처는 메서드의 이름 뿐만 아니라 매개변수의 타입, 반환 타입 등을 포함한 개념.  특히 **오버로딩**하는 경우에 있어서 중요한데 함수의 오버로딩은 메서드 시그니처를 통해 식별하기 때문. 이러한 메서드 시그니처를 신중히 설계하는 것이 코드의 가독성과 유지보수성을 높이는 데 기여할 수 있다.

## 1. 메서드 이름을 신중히 짓자

메서드 이름은 해당 메서드가 하는 일을 명확하게 설명해주는 역할을 합니다. 따라서 메서드 이름을 잘못 지으면 코드의 가독성 및 유지보수성이 떨어질 수 있다.

### 메서드 이름을 지을 때 고려해야 할 사항

1. 메서드 이름은 해당 메서드가 하는 일을 명확하게 설명해야 함.
2. 메서드 이름은 동사로 시작하여 어떤 행동을 하는지 알려주어야 함.
3. 메서드 이름은 간결하고 명료해야 함.
4. 메서드 이름은 일관성 있게 지어야 함.

### 잘못된 메서드 이름의 예

```java
// 잘못된 메서드 이름 - 이름만 보면 어떤 연산을 수행하는지 알기 어려움
public static List<Integer> generate(int n) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        result.add(i);
    }
    return result;
}
```

위 예시 코드에서 **`generate`**메서드는 정수 n을 입력받아서 0부터 n-1까지의 정수를 가지는 리스트를 생성하여 반환함. 하지만 이 메서드의 이름만 보고는, 어떤 연산을 수행하는지 쉽게 알 수 없음.

### 올바른 메서드 이름의 예

```java
// 올바른 메서드 이름 - 이름만 보면 어떤 연산을 수행하는지 알기 쉬움
public static List<Integer> generateSequence(int sequenceSize) {
    List<Integer> sequence = new ArrayList<>();
    for (int i = 0; i < sequenceSize; i++) {
        sequence.add(i);
    }
    return sequence;
}
```

**`generateSequence`** 메서드는 이름만 보고도, 정수 sequenceSize에 따라서 연속된 정수 수열을 생성하는 것을 알 수 있음. 이렇게 메서드 이름을 잘 지으면, 사용자가 API를 더욱 쉽게 이해하고 사용할 수 있겠지?

## 2. 편의 메서드를 너무 많이 만들지 말자

**편의 메서드(convenience method)**는, 자주 사용되는 기능을 쉽게 사용할 수 있도록, 더 간단한 인터페이스를 제공하는 메서드를 말함. 예를 들어, `Arrays` 클래스에는 배열을 쉽게 출력할 수 있도록 `toString` 메서드가 잘 정의되어 있다. 이 메서드를 사용하면, 루프를 돌며 각 요소를 출력해야 하는 귀찮은 일을 안해도 된다.

그러나 편의 메서드를 너무 많이 만들다 보면, 오히려 API를 복잡하게 만들 수도 있다. 특히 여러 개의 인터페이스를 구현하는 클래스에서는, 각 인터페이스에 맞는 편의 메서드를 모두 만들면 API가 몹시 복잡해질 수 있다. 또한, 편의 메서드를 많이 만들다 보면, API가 변경될 때마다 편의 메서드를 수정해줘야 하는 불편함도 있음.

따라서, 편의 메서드를 만들 때에는 다음과 같은 사항들을 고려해야 함.

### 편의 메서드를 만들 때 고려해야 할 사항

1. 최소한의 인터페이스만 제공하며, 필요하다면 인터페이스의 디폴트 메서드(default method)를 사용하라.
2. 공개된 API에서는 편의 메서드보다 기본 메서드를 사용하는 것이 더 좋다.
3. 편의 메서드를 과도하게 만들지 않도록 하라.

### 잘못된 예시

```java
// 잘못된 예시 - 편의 메서드를 과도하게 만들었다.
public class Stack<E> {
    public boolean isEmpty();
    public void push(E e);
    public E pop();
    public E peek();

    public boolean contains(E e);
    public int size();
    public void clear();

    public boolean pushAll(Iterable<? extends E> src);
    public boolean popAll(Collection<? super E> dst);
}

```

위 예시의 `Stack` 클래스는, `isEmpty`, `push`, `pop`, `peek` 등의 기본 메서드들 뿐만 아니라, `contains`, `size`, `clear` 등의 편의 메서드들도 제공하고 있다. 이렇게 되면, 사용자가 API를 이해하기 위해 여러 개의 메서드를 파악해야 하므로, API가 복잡해진다.

### 올바른 예시

```java
// 올바른 예시 - 최소한의 인터페이스만 제공했다.
public interface Stack<E> {
    boolean isEmpty();
    void push(E e);
    E pop();
}

```

위 예시의 `Stack` 인터페이스는, 최소한의 인터페이스만 제공하고 있다. 이렇게 되면, 사용자는 필요한 정보만을 쉽게 파악할 수 있으므로, API가 단순해진다. 만약 사용자가 `contains`, `size`, `clear` 등의 기능을 사용하고 싶다면, 이를 위한 **별도의 인터페이스**를 만들어서 사용하는 것이 더 좋다.

## 3. 매개변수 목록은 짧게 유지하자

메서드에서 받는 매개변수는 매개변수 목록이 길어지면, 코드의 가독성과 유지보수성을 떨어뜨릴 수 있다. 특히, 4개 이상의 매개변수를 받는 메서드는 피하는 것이 좋다. 이는 다음과 같은 이유 때문이다.

1. 매개변수가 많아지면, 각 매개변수의 의미를 이해하기 어려워진다. 또한, 각 매개변수의 타입을 기억하기도 어려워진다.
2. 매개변수가 많아지면, 메서드를 호출하는 코드도 길어지기 때문에, 가독성이 떨어진다.
3. 매개변수가 많아지면, 매개변수의 순서를 기억하기 어려워진다. 이는 실수를 유발할 가능성이 높다.

만약 매개변수를 줄일 수 없는 경우, 다음과 같은 방법들을 고려해볼 수 있다.

### 1. 메서드를 여러개로 쪼갠다.

메서드의 매개변수가 많아지면, 이를 여러 개의 메서드로 나눌 수 있다. 이를 통해 사용자는 필요한 매개변수만을 전달하면 되므로, 가독성이 높아진다.

### 2. 매개변수를 객체로 만든다.

매개변수가 많아지면, 이를 객체로 만들어서 전달하는 것이 좋다. 이를 통해 매개변수를 줄일 수 있을 뿐만 아니라, 객체의 필드명을 통해 매개변수의 의미를 명확하게 전달할 수 있다.

### 3. Builder 패턴을 사용한다.

매개변수가 많은 경우, Builder 패턴을 사용하여 메서드를 호출하는 코드를 깔끔하게 만들 수 있다. 이를 통해 가독성이 높아지며, 코드의 유지보수성도 높아진다.

위와 같은 방법들을 사용하여, 매개변수 목록을 최대한 짧게 유지하도록 노력해야 한다.

## 4. 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다

```java
// 잘못된 예 - 매개변수로 구체 클래스를 사용함
public void printList(ArrayList<String> list) {
    for (String item : list) {
        System.out.println(item);
    }
}

// 올바른 예 - 매개변수로 인터페이스를 사용함
public void printList(List<String> list) {
    for (String item : list) {
        System.out.println(item);
    }
}
```

이렇게 매개변수로 인터페이스를 사용할 때 메서드를 더 범용적으로 사용할 수 있게 된다. `ArrayList` 클래스 대신 `List` 인터페이스를 사용하면, 다른 `List` 인터페이스를 구현한 클래스들도 매개변수로 사용할 수 있다. 따라서, 메서드의 유연성과 재사용성이 높아지게 된다.

## 5. boolean보다는 원소 2개짜리 열거 타입이 낫다

boolean 타입은 두 가지 상태를 표현할 수 있는 가장 간단한 타입이긴 하지만,  코드의 가독성과 유지보수성이 떨어지는 단점이 있을 수 있음. 이를 해결할 아주 좋은 방법이 원소 2개짜리 열거 타입이다. 

원소 2개짜리 열거 타입을 사용하면, 코드를 이해하기 위해서는 해당 열거 타입의 이름만으로 두 가지 상태를 파악할 수 있다. 이는 변수의 이름이 어려울 경우에도 사용자가 코드를 이해하기 쉽게 만든다.

```java
// boolean 타입 사용
public class State {
    private boolean isActive;

    public State(boolean isActive) {
        this.isActive = isActive;
    }

    public boolean isActive() {
        return isActive;
    }
}

// 원소 2개짜리 열거 타입 사용
public enum State {
    ACTIVE,
    INACTIVE,
}

```

위 예시에서 `State` 클래스와 `State` 열거 타입은 기능은 똑같지만 클라이언트는 당연히 가독성이 높은 아래 쪽을 선호할 것.